<!DOCTYPE html>
<!-- saved from url=(0048)http://www.voidcn.com/article/p-wohpkcfq-gt.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/analytics.js.下载"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HttpClient 4.3连接池参数配置及源码解读 - 程序园</title>
    <meta name="keywords" content="httpclient,4.3,4,3,连接,池,参数,配置,源码,解读">
    <meta name="description" content="    目前所在公司使用HttpClient 4.3.3版本发送Rest请求，调用接口。最近出现了调用查询接口服务慢的生产问题，在排查整个调用链可能存在的问题时（从客户端发起Http请求-&gt;ESB-&gt;服务端处理请求，查询数据并返回），发现原本的HttpClient连接池中的一些参数配置可能存在问题，如defaultMaxPerRoute、一些timeout时间的设置等，虽不能确定是由于此连接池导致">
    <meta name="google-site-verification" content="eVo932LL8QghamZXYXdbvMxZcdr2v6nNXj2f7mfA1cw">
    
    <link rel="shortcut icon" href="http://static02.voidcn.com/voidcn/favicon.ico" type="image/x-icon">
    <link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/pub.min.css" rel="stylesheet">
    <link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/application.min.css" media="screen" rel="stylesheet" type="text/css">
    <link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/font-awesome.css" rel="stylesheet">
    
    <script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/hm.js.下载"></script><script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/pub.js.下载" type="text/javascript"></script><style type="text/css" abt="234"></style>
    <script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/application.js.下载" type="text/javascript"></script>
    
<script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/share.js.下载"></script><link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/share.css" rel="styleSheet" type="text/css"></head>

<body class="  pace-done"><div class="pace  pace-inactive"><div class="pace-progress" data-progress-text="100%" data-progress="99" style="transform: translate3d(100%, 0px, 0px);">
  <div class="pace-progress-inner"></div>
</div>
<div class="pace-activity"></div></div>

<div id="header" class="navbar-fixed-top">
    <div class="container">
        <div class="navbar">
            <div class="navbar-inner">
                <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>
                <a href="http://www.voidcn.com/" class="brand">程序园</a>
                <nav class="nav-collapse collapse">
                    <ul class="nav navbar primary-nav">
                        <li class="">
                            <a href="http://www.voidcn.com/column">栏目</a>
                        </li>
                        <li class="">
                            <a href="http://www.voidcn.com/tag">标签</a>
                        </li>
                        <li class="">
                            <a href="http://www.voidcn.com/cata">分类</a>
                        </li>
                        <li class="">
                            <a href="http://www.voidcn.com/course">教程</a>
                        </li>
                        <li class="">
                            <a href="http://www.voidcn.com/code">代码</a>
                        </li>
                    </ul>
                    <form class="navbar-search pull-left" action="http://www.voidcn.com/gsearch">
						<input type="text" class="search-query span2" name="q" placeholder="搜索">
					</form>
                    <ul class="nav pull-right">
                        <li><a href="javascript:void()"></a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </div>
</div><link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/share(1).css" rel="stylesheet">
<link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/fontello.css" rel="stylesheet">

<div class="container-fluid">
	<div class="row-fluid article_row_fluid">

<div class="span9 contant article_detail_bg">

	<h1>HttpClient 4.3连接池参数配置及源码解读</h1>
	
    <div class="article_meta">
        <div style="margin-bottom: 2px;">
    		<span class="timestamp">时间&nbsp;&nbsp;2017-02-05</span>
        </div>

			<div style="margin-bottom: 2px;">
					<span>栏目</span>
					<a target="_blank" href="http://www.voidcn.com/column/network" title="系统网络"> <span class="new-label">系统网络</span></a>
	        </div>
        
	        <div>
	        	<span class="source">
	            	<i style="float:left;">原文</i>&nbsp;&nbsp;
	            	<a id="originfo" class="cut cut70" href="javascript:void()" target="_blank" tyle="display:inline-block;" rel="nofollow">http://blog.csdn.net/umke888/article/details/54881946</a>
	    		</span>
	        </div>
    </div>
    <div class="article_body" id="nei">
	    	<div><script async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/f.txt"></script>
<!-- 正文顶部广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6208739752673518" data-ad-slot="8264218718" data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
        <div>
           <p>&nbsp;&nbsp;&nbsp; <span style="font-size:14px">目前所在公司</span>使用HttpClient 4.3.3版本发送Rest请求，调用接口。最近出现了调用查询接口服务慢的生产问题，在排查整个调用链可能存在的问题时（从客户端发起Http请求-&gt;ESB-&gt;服务端处理请求，查询数据并返回），发现原本的HttpClient连接池中的一些参数配置可能存在问题，如defaultMaxPerRoute、一些timeout时间的设置等，虽不能确定是由于此连接池导致接口查询慢，但确实存在可优化的地方，故花时间做一些研究。本文主要涉及HttpClient连接池、请求的参数配置，<span style="font-size:large"><span style="font-size:14px">使用及源码解读。</span></span></p> 
<p>&nbsp;</p> 
<p>&nbsp;&nbsp;&nbsp; 以下是本文的目录大纲：</p> 
<p>&nbsp;&nbsp;&nbsp; 一、HttpClient连接池、请求参数含义</p> 
<p>&nbsp;&nbsp;&nbsp; 二、执行原理及源码解读</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、创建HttpClient，执行request</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、连接池管理</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1、连接池结构</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2、分配连接 &amp; 建立连接</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3、回收连接 &amp; 保持连接</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.4、instream.close()、response.close()、httpclient.close()的区别</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5、过期和空闲连接清理</p> 
<p>&nbsp;&nbsp;&nbsp; 三、如何设置合理的参数</p> 
<p>&nbsp;</p> 
<h1>一、HttpClient连接池、请求参数含义</h1> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.io.InterruptedIOException;
<span class="hljs-keyword">import</span> java.net.UnknownHostException;
<span class="hljs-keyword">import</span> java.nio.charset.CodingErrorAction;
<span class="hljs-keyword">import</span> javax.net.ssl.SSLException;
<span class="hljs-keyword">import</span> org.apache.http.Consts;
<span class="hljs-keyword">import</span> org.apache.http.HttpEntity;
<span class="hljs-keyword">import</span> org.apache.http.HttpEntityEnclosingRequest;
<span class="hljs-keyword">import</span> org.apache.http.HttpHost;
<span class="hljs-keyword">import</span> org.apache.http.HttpRequest;
<span class="hljs-keyword">import</span> org.apache.http.client.HttpRequestRetryHandler;
<span class="hljs-keyword">import</span> org.apache.http.client.config.RequestConfig;
<span class="hljs-keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;
<span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;
<span class="hljs-keyword">import</span> org.apache.http.client.protocol.HttpClientContext;
<span class="hljs-keyword">import</span> org.apache.http.config.ConnectionConfig;
<span class="hljs-keyword">import</span> org.apache.http.config.MessageConstraints;
<span class="hljs-keyword">import</span> org.apache.http.config.SocketConfig;
<span class="hljs-keyword">import</span> org.apache.http.conn.ConnectTimeoutException;
<span class="hljs-keyword">import</span> org.apache.http.conn.routing.HttpRoute;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.DefaultHttpRequestRetryHandler;
<span class="hljs-keyword">import</span> org.apache.http.impl.client.HttpClients;
<span class="hljs-keyword">import</span> org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
<span class="hljs-keyword">import</span> org.apache.http.protocol.HttpContext;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientParamTest</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
		<span class="hljs-javadoc">/**
		 * 创建连接管理器，并设置相关参数
		 */</span>
		<span class="hljs-comment">//连接管理器，使用无惨构造</span>
		PoolingHttpClientConnectionManager connManager 
		                            = <span class="hljs-keyword">new</span> PoolingHttpClientConnectionManager();
		
		<span class="hljs-javadoc">/**
		 * 连接数相关设置
		 */</span>
		<span class="hljs-comment">//最大连接数</span>
		connManager.setMaxTotal(<span class="hljs-number">200</span>); 
		<span class="hljs-comment">//默认的每个路由的最大连接数</span>
		connManager.setDefaultMaxPerRoute(<span class="hljs-number">100</span>); 
		<span class="hljs-comment">//设置到某个路由的最大连接数，会覆盖defaultMaxPerRoute</span>
		connManager.setMaxPerRoute(<span class="hljs-keyword">new</span> HttpRoute(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"somehost"</span>, <span class="hljs-number">80</span>)), <span class="hljs-number">150</span>); 
		
		<span class="hljs-javadoc">/**
		 * socket配置（默认配置 和 某个host的配置）
		 */</span>
		SocketConfig socketConfig = SocketConfig.custom()
				.setTcpNoDelay(<span class="hljs-keyword">true</span>)     <span class="hljs-comment">//是否立即发送数据，设置为true会关闭Socket缓冲，默认为false</span>
				.setSoReuseAddress(<span class="hljs-keyword">true</span>) <span class="hljs-comment">//是否可以在一个进程关闭Socket后，即使它还没有释放端口，其它进程还可以立即重用端口</span>
				.setSoTimeout(<span class="hljs-number">500</span>)       <span class="hljs-comment">//接收数据的等待超时时间，单位ms</span>
				.setSoLinger(<span class="hljs-number">60</span>)         <span class="hljs-comment">//关闭Socket时，要么发送完所有数据，要么等待60s后，就关闭连接，此时socket.close()是阻塞的</span>
	            .setSoKeepAlive(<span class="hljs-keyword">true</span>)    <span class="hljs-comment">//开启监视TCP连接是否有效</span>
	            .build();
		connManager.setDefaultSocketConfig(socketConfig);
		connManager.setSocketConfig(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"somehost"</span>, <span class="hljs-number">80</span>), socketConfig);
		
		<span class="hljs-javadoc">/**
		 * HTTP connection相关配置（默认配置 和 某个host的配置）
		 * 一般不修改HTTP connection相关配置，故不设置
		 */</span>
		<span class="hljs-comment">//消息约束</span>
		MessageConstraints messageConstraints = MessageConstraints.custom()
	            .setMaxHeaderCount(<span class="hljs-number">200</span>)
	            .setMaxLineLength(<span class="hljs-number">2000</span>)
	            .build();
		<span class="hljs-comment">//Http connection相关配置</span>
		ConnectionConfig connectionConfig = ConnectionConfig.custom()
	            .setMalformedInputAction(CodingErrorAction.IGNORE)
	            .setUnmappableInputAction(CodingErrorAction.IGNORE)
	            .setCharset(Consts.UTF_8)
	            .setMessageConstraints(messageConstraints)
	            .build();
		<span class="hljs-comment">//一般不修改HTTP connection相关配置，故不设置</span>
		<span class="hljs-comment">//connManager.setDefaultConnectionConfig(connectionConfig);</span>
        <span class="hljs-comment">//connManager.setConnectionConfig(new HttpHost("somehost", 80), ConnectionConfig.DEFAULT);</span>
		
        <span class="hljs-javadoc">/**
         * request请求相关配置
         */</span>
		RequestConfig defaultRequestConfig = RequestConfig.custom()
				.setConnectTimeout(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>)         <span class="hljs-comment">//连接超时时间</span>
                .setSocketTimeout(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>)          <span class="hljs-comment">//读超时时间（等待数据超时时间）</span>
                .setConnectionRequestTimeout(<span class="hljs-number">500</span>)    <span class="hljs-comment">//从池中获取连接超时时间</span>
                .setStaleConnectionCheckEnabled(<span class="hljs-keyword">true</span>)<span class="hljs-comment">//检查是否为陈旧的连接，默认为true，类似testOnBorrow</span>
                .build();
		
		<span class="hljs-javadoc">/**
		 * 重试处理
		 * 默认是重试3次
		 */</span>
		<span class="hljs-comment">//禁用重试(参数：retryCount、requestSentRetryEnabled)</span>
		HttpRequestRetryHandler requestRetryHandler = <span class="hljs-keyword">new</span> DefaultHttpRequestRetryHandler(<span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);
		<span class="hljs-comment">//自定义重试策略</span>
		HttpRequestRetryHandler myRetryHandler = <span class="hljs-keyword">new</span> HttpRequestRetryHandler() {

		    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retryRequest</span><span class="hljs-params">(IOException exception, <span class="hljs-keyword">int</span> executionCount, HttpContext context)</span> </span>{
		    	<span class="hljs-comment">//Do not retry if over max retry count</span>
		        <span class="hljs-keyword">if</span> (executionCount &gt;= <span class="hljs-number">3</span>) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		        }
		        <span class="hljs-comment">//Timeout</span>
		        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> InterruptedIOException) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		        }
		        <span class="hljs-comment">//Unknown host</span>
		        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> UnknownHostException) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		        }
		        <span class="hljs-comment">//Connection refused</span>
		        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ConnectTimeoutException) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		        }
		        <span class="hljs-comment">//SSL handshake exception</span>
		        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> SSLException) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		        }
		        
		        HttpClientContext clientContext = HttpClientContext.adapt(context);
		        HttpRequest request = clientContext.getRequest();
		        <span class="hljs-keyword">boolean</span> idempotent = !(request <span class="hljs-keyword">instanceof</span> HttpEntityEnclosingRequest);
		        <span class="hljs-comment">//Retry if the request is considered idempotent</span>
		        <span class="hljs-comment">//如果请求类型不是HttpEntityEnclosingRequest，被认为是幂等的，那么就重试</span>
		        <span class="hljs-comment">//HttpEntityEnclosingRequest指的是有请求体的request，比HttpRequest多一个Entity属性</span>
		        <span class="hljs-comment">//而常用的GET请求是没有请求体的，POST、PUT都是有请求体的</span>
		        <span class="hljs-comment">//Rest一般用GET请求获取数据，故幂等，POST用于新增数据，故不幂等</span>
		        <span class="hljs-keyword">if</span> (idempotent) {
		            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
		        }
		        
		        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		    }
		};
		
		<span class="hljs-javadoc">/**
		 * 创建httpClient
		 */</span>
		CloseableHttpClient httpclient = HttpClients.custom()
	            .setConnectionManager(connManager)             <span class="hljs-comment">//连接管理器</span>
	            .setProxy(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"myproxy"</span>, <span class="hljs-number">8080</span>))       <span class="hljs-comment">//设置代理</span>
	            .setDefaultRequestConfig(defaultRequestConfig) <span class="hljs-comment">//默认请求配置</span>
	            .setRetryHandler(myRetryHandler)               <span class="hljs-comment">//重试策略</span>
	            .build();
		
		<span class="hljs-comment">//创建一个Get请求，并重新设置请求参数，覆盖默认</span>
		HttpGet httpget = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://www.somehost.com/"</span>);
        RequestConfig requestConfig = RequestConfig.copy(defaultRequestConfig)
            .setSocketTimeout(<span class="hljs-number">5000</span>)
            .setConnectTimeout(<span class="hljs-number">5000</span>)
            .setConnectionRequestTimeout(<span class="hljs-number">5000</span>)
            .setProxy(<span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"myotherproxy"</span>, <span class="hljs-number">8080</span>))
            .build();
        httpget.setConfig(requestConfig);
        
        CloseableHttpResponse response = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
        	<span class="hljs-comment">//执行请求</span>
			response = httpclient.execute(httpget);
			
			HttpEntity entity = response.getEntity();
			
			<span class="hljs-comment">// If the response does not enclose an entity, there is no need</span>
            <span class="hljs-comment">// to bother about connection release</span>
            <span class="hljs-keyword">if</span> (entity != <span class="hljs-keyword">null</span>) {
                InputStream instream = entity.getContent();
                <span class="hljs-keyword">try</span> {
                    instream.read();
                    <span class="hljs-comment">// do something useful with the response</span>
                } 
                <span class="hljs-keyword">catch</span> (IOException ex) {
                    <span class="hljs-comment">// In case of an IOException the connection will be released</span>
                    <span class="hljs-comment">// back to the connection manager automatically</span>
                    <span class="hljs-keyword">throw</span> ex;
                } 
                <span class="hljs-keyword">finally</span> {
                    <span class="hljs-comment">// Closing the input stream will trigger connection release</span>
                	<span class="hljs-comment">// 释放连接回到连接池</span>
                    instream.close();
                }
            }
		} 
        <span class="hljs-keyword">catch</span> (Exception e) {
			e.printStackTrace();
		} 
        <span class="hljs-keyword">finally</span>{
        	<span class="hljs-keyword">if</span>(response != <span class="hljs-keyword">null</span>){
        		<span class="hljs-keyword">try</span> {
        			<span class="hljs-comment">//关闭连接(如果已经释放连接回连接池，则什么也不做)</span>
    				response.close();
    			} <span class="hljs-keyword">catch</span> (IOException e) {
    				e.printStackTrace();
    			}
        	}
        	
        	<span class="hljs-keyword">if</span>(httpclient != <span class="hljs-keyword">null</span>){
        		<span class="hljs-keyword">try</span> {
        			<span class="hljs-comment">//关闭连接管理器，并会关闭其管理的连接</span>
        			httpclient.close();
        		} <span class="hljs-keyword">catch</span> (IOException e) {
        			e.printStackTrace();
        		}
        	}
        }
	}
}</pre> 
<div class="cnblogs_Highlighter">
  &nbsp;&nbsp;&nbsp; 上面的代码参考httpClient 4.3.x的官方样例，其实官方样例中可配置的更多，我只将一些觉得平时常用的摘了出来，其实我们在实际使用中也是使用默认的 socketConfig 和 connectionConfig。具体参数含义请看注释。 
</div> 
<p>&nbsp;&nbsp;&nbsp; 个人感觉在实际应用中连接数相关配置（如maxTotal、maxPerRoute），还有请求相关的超时时间设置（如connectionTimeout、socketTimeout、connectionRequestTimeout）是比较重要的。</p> 
<p>&nbsp;&nbsp;&nbsp; 连接数配置有问题就可能产生总的 连接数不够 或者 到某个路由的连接数太小 的问题，我们公司一些项目总连接数800，而defaultMaxPerRoute仅为20，这样导致真正需要比较多连接数，访问量比较大的路由也仅能从连接池中获取最大20个连接，应该在默认的基础上，针对访问量大的路由单独设置。</p> 
<p>&nbsp;&nbsp;&nbsp; 连接超时时间，读超时时间，从池中获取连接的超时时间如果不设置或者设置的太大，可能导致当业务高峰时，服务端响应较慢 或 连接池中确实没有空闲连接时，不能够及时将timeout异常抛出来，导致等待读取数据的，或者等待从池中获取连接的越积越多，像滚雪球一样，导致相关业务都开始变得缓慢，而如果配置合理的超时时间就可以及时抛出异常，发现问题。</p> 
<p>&nbsp;&nbsp;&nbsp; 后面会尽量去阐述这些重要参数的原理以及如何配置一个合适的值。</p> 
<p>&nbsp;</p> 
<h1>二、执行原理及源码解读</h1> 
<p><strong><span style="color:#0000ff">1、创建HttpClient，执行request</span></strong></p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cpp"><span class="hljs-comment">/**
 * 创建httpClient
 */</span>
CloseableHttpClient httpclient = HttpClients.custom()
                                 .setConnectionManager(connManager)             <span class="hljs-comment">//连接管理器</span>
                                 .setDefaultRequestConfig(defaultRequestConfig) <span class="hljs-comment">//默认请求配置</span>
                                 .setRetryHandler(myRetryHandler)               <span class="hljs-comment">//重试策略</span>
                                 .build();</pre> 
<p>&nbsp;&nbsp;&nbsp; 创建HttpClient的过程就是在设置了“连接管理器”、“请求相关配置”、“重试策略”后，调用 HttpClientBuilder.build()。</p> 
<p>&nbsp;&nbsp;&nbsp; build()方法会根据设置的属性不同，创建不同的Executor执行器，如设置了retryHandler就会 new RetryExec(execChain, retryHandler)，相当于retry Executor。当然有些Executor是必须创建的，如MainClientExec、ProtocolExec。最后new InternalHttpClient(execChain, connManager, routePlanner …)并返回。</p> 
<p>&nbsp;</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs nginx"><span class="hljs-title">CloseableHttpResponse</span> httpResponse = httpClient.execute(httpUriRequest);</pre> 
<p>&nbsp;&nbsp;&nbsp; HttpClient使用了<span style="color:#ff0000">责任链模式</span>，所有Executor都实现了ClientExecChain接口的execute()方法，每个Executor都持有下一个要执行的Executor的引用，这样就会形成一个Executor的执行链条，请求在这个链条上传递。按照上面的方式构造的httpClient形成的执行链条为：</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cpp">HttpRequestExecutor                              <span class="hljs-comment">//发送请求报文，并接收响应信息</span>
MainClientExec(requestExec, connManager, ...)    <span class="hljs-comment">//main Executor，负责连接管理相关</span>
ProtocolExec(execChain, httpprocessor)           <span class="hljs-comment">//HTTP协议封装</span>
RetryExec(execChain, retryHandler)               <span class="hljs-comment">//重试策略</span>
RedirectExec(execChain, routePlanner, redirectStrategy)   <span class="hljs-comment">//重定向</span></pre> 
<p>&nbsp;&nbsp;&nbsp; 请求执行是按照从下到上的顺序（即每个下面的Executor都持有上面一个Executor的引用），每一个执行器都会负责请求过程中的一部分工作，最终返回response。</p> 
<p>&nbsp;</p> 
<p><strong><span style="color:#0000ff">2、连接池管理</span></strong></p> 
<p><strong>2.1、连接池结构</strong></p> 
<p>连接池结构图如下:</p> 
<p><img title="6f3717d34737_thumb2" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/loading.png" alt="6f3717d34737_thumb2" width="562" height="389" border="0" style="padding-top: 0px; padding-left: 0px; margin: 0px; display: block; padding-right: 0px; border-width: 0px; height: 550px; width: 550px;" data-src="http://images2015.cnblogs.com/blog/677054/201701/677054-20170125150656456-1638279999.png"></p> 
<p><span style="color:#9b00d3">PoolEntry&lt;HttpRoute, ManagedHttpClientConnection&gt;&nbsp; --&nbsp; 连接池中的实体</span></p> 
<p>包含ManagedHttpClientConnection连接；</p> 
<p>连接的route路由信息；</p> 
<p>以及连接存活时间相隔信息，如created（创建时间），updated（更新时间，释放连接回连接池时会更新），validUnit（用于初始化expiry过期时间，规则是如果timeToLive&gt;0，则为created+timeToLive，否则为Long.MAX_VALUE），expiry（过期时间，人为规定的连接池可以保有连接的时间，除了初始化时等于validUnit，每次释放连接时也会更新，但是从newExpiry和validUnit取最小值）。timeToLive是在构造连接池时指定的连接存活时间，默认构造的timeToLive=-1。</p> 
<p>ManagedHttpClientConnection是httpClient连接，真正建立连接后，其会bind绑定一个socket，用于传输HTTP报文。</p> 
<p><span style="color:#9b00d3">LinkedList&lt;PoolEntry&gt;&nbsp; available&nbsp; --&nbsp; 存放可用连接</span></p> 
<p>使用完后所有可重用的连接回被放到available链表头部，之后再获取连接时优先从available链表头部迭代可用的连接。</p> 
<p>之所以使用LinkedList是利用了其队列的特性，即可以在队首和队尾分别插入、删除。入available链表时都是addFirst()放入头部，获取时都是从头部依次迭代可用的连接，这样可以获取到最新放入链表的连接，其离过期时间更远（这种策略可以尽量保证获取到的连接没有过期，而从队尾获取连接是可以做到在连接过期前尽量使用，但获取到过期连接的风险就大了），删除available链表中连接时是从队尾开始，即先删除最可能快要过期的连接。</p> 
<p><span style="color:#9b00d3">HashSet&lt;PoolEntry&gt;&nbsp; leased&nbsp; --&nbsp; 存放被租用的连接</span></p> 
<p>所有正在被使用的连接存放的集合，只涉及 add() 和 remove() 操作。</p> 
<p>maxTotal限制的是外层httpConnPool中leased集合和available队列的总和的大小，leased和available的大小没有单独限制。</p> 
<p><span style="color:#9b00d3">LinkedList&lt;PoolEntryFuture&gt;&nbsp; pending&nbsp; --&nbsp; 存放等待获取连接的线程的Future</span></p> 
<p>当从池中获取连接时，如果available链表没有现成可用的连接，且当前路由或连接池已经达到了最大数量的限制，也不能创建连接了，此时不会阻塞整个连接池，而是将当前线程用于获取连接的Future放入pending链表的末尾，之后当前线程调用await()，释放持有的锁，并等待被唤醒。</p> 
<p>当有连接被release()释放回连接池时，会从pending链表头获取future，并唤醒其线程继续获取连接，做到了先进先出。</p> 
<p><span style="color:#9b00d3">routeToPool&nbsp; --&nbsp; 每个路由对应的pool</span></p> 
<p>也有针对当前路由的available、leased、pending集合，与整个池的隔离。</p> 
<p>maxPerRoute限制的是routeToPool中leased集合和available队列的总和的大小。</p> 
<p>&nbsp;</p> 
<p><strong>2.2、分配连接 &amp; 建立连接</strong></p> 
<p><span style="color:#9b00d3"><strong>分配连接</strong></span></p> 
<p>分配连接指的是从连接池获取可用的PoolEntry，大致过程为：</p> 
<p>1、获取route对应连接池routeToPool中可用的连接，有则返回该连接，若没有则转入下一步；</p> 
<p>2、若routeToPool和外层HttpConnPool连接池均还有可用的空间，则新建连接，并将该连接作为可用连接返回，否则进行下一步；</p> 
<p>3、挂起当前线程，将当前线程的Future放入pending队列，等待后续唤醒执行；</p> 
<p>整个分配连接的过程采用了异步操作，只在前两步时锁住连接池，一旦发现无法获取连接则释放锁，等待后续继续获取连接。</p> 
<p><span style="color:#9b00d3"><strong>建立连接</strong></span></p> 
<p>当分配到PoolEntry连接实体后，会调用establishRoute()，建立socket连接并与conn绑定。</p> 
<p>&nbsp;</p> 
<p><strong>2.3、回收连接 &amp; 保持连接</strong></p> 
<p><span style="color:#9b00d3"><strong>回收连接</strong></span></p> 
<p>连接用完之后连接池需要进行回收（<span style="color:#ff0000">AbstractConnPool#release()</span>），具体流程如下：<br> 1、若当前连接标记为重用，则将该连接从routeToPool中的leased集合删除，并添加至available队首，同样的将该请求从外层httpConnPool的leased集合删除，并添加至其available队首。同时唤醒该routeToPool的pending队列的第一个PoolEntryFuture，将其从pending队列删除，并将其从外层httpConnPool的pending队列中删除。<br> 2、若连接没有标记为重用，则分别从routeToPool和外层httpConnPool中删除该连接，并关闭该连接。</p> 
<p><span style="color:#9b00d3"><strong>保持连接</strong></span></p> 
<p>MainClientExec#execute()是负责连接管理的，在执行完后续调用链，并得到response后，会调用保持连接的逻辑，如下：</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cpp"><span class="hljs-comment">// The connection is in or can be brought to a re-usable state.</span>
<span class="hljs-comment">// 根据response头中的信息判断是否保持连接</span>
<span class="hljs-keyword">if</span> (reuseStrategy.keepAlive(response, context)) {
    <span class="hljs-comment">// Set the idle duration of this connection</span>
	<span class="hljs-comment">// 根据response头中的keep-alive中的timeout属性，得到连接可以保持的时间（ms）</span>
    final <span class="hljs-keyword">long</span> duration = keepAliveStrategy.getKeepAliveDuration(response, context);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-built_in">log</span>.isDebugEnabled()) {
        final String s;
        <span class="hljs-keyword">if</span> (duration &gt; <span class="hljs-number">0</span>) {
            s = <span class="hljs-string">"for "</span> + duration + <span class="hljs-string">" "</span> + TimeUnit.MILLISECONDS;
        } <span class="hljs-keyword">else</span> {
            s = <span class="hljs-string">"indefinitely"</span>;
        }
        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">log</span>.debug(<span class="hljs-string">"Connection can be kept alive "</span> + s);
    }
    <span class="hljs-comment">//设置连接保持时间，最终是调用 PoolEntry#updateExpiry</span>
    connHolder.setValidFor(duration, TimeUnit.MILLISECONDS);
    connHolder.markReusable(); <span class="hljs-comment">//设置连接reuse=true</span>
} 
<span class="hljs-keyword">else</span> {
    connHolder.markNonReusable();
}</pre> 
<p><span style="color:#ff0000">连接是否保持</span></p> 
<p>客户端如果希望保持长连接，应该在发起请求时告诉服务器希望服务器保持长连接（http 1.0设置connection字段为keep-alive，http 1.1字段默认保持）。根据服务器的响应来确定是否保持长连接，判断原则如下：</p> 
<p>1、检查返回response报文头的Transfer-Encoding字段，若该字段值存在且不为chunked，则连接不保持，直接关闭。其他情况进入下一步；<br> 2、检查返回的response报文头的Content-Length字段，若该字段值为空或者格式不正确（多个长度，值不是整数）或者小于0，则连接不保持，直接关闭。其他情况进入下一步<br> 3、检查返回的response报文头的connection字段（若该字段不存在，则为Proxy-Connection字段）值，如果字段存在，若字段值为close 则连接不保持，直接关闭，若字段值为keep-alive则连接标记为保持。如果这俩字段都不存在，则http 1.1版本默认为保持，将连接标记为保持， 1.0版本默认为连接不保持，直接关闭。</p> 
<p><span style="color:#ff0000">连接保持时间</span></p> 
<p>连接交还至连接池时，若连接标记为保持reuse=true，则将由连接管理器保持一段时间；若连接没有标记为保持，则直接从连接池中删除并关闭entry。<br> 连接保持时，会更新PoolEntry的expiry到期时间，计算逻辑为：<br> 1、如果response头中的keep-alive字段中timeout属性值存在且为正值：newExpiry = 连接归还至连接池时间System.currentTimeMillis() + timeout；<br> 2、如timeout属性值不存在或为负值：newExpiry = Long.MAX_VALUE（无穷）<br> 3、最后会和PoolEntry原本的expiry到期时间比较，选出一个最小值作为新的到期时间。</p> 
<p>&nbsp;</p> 
<p><strong>2.4、instream.close()、response.close()、httpclient.close()的区别</strong></p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cs"><span class="hljs-comment">/**
 * This example demonstrates the recommended way of using API to make sure
 * the underlying connection gets released back to the connection manager.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClientConnectionRelease</span> {

    <span class="hljs-function"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> throws Exception </span>{
        CloseableHttpClient httpclient = HttpClients.createDefault();
        <span class="hljs-keyword">try</span> {
            HttpGet httpget = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://localhost/"</span>);

            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Executing request "</span> + httpget.getRequestLine());
            CloseableHttpResponse response = httpclient.execute(httpget);
            <span class="hljs-keyword">try</span> {
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"----------------------------------------"</span>);
                System.<span class="hljs-keyword">out</span>.println(response.getStatusLine());

                <span class="hljs-comment">// Get hold of the response entity</span>
                HttpEntity entity = response.getEntity();

                <span class="hljs-comment">// If the response does not enclose an entity, there is no need</span>
                <span class="hljs-comment">// to bother about connection release</span>
                <span class="hljs-keyword">if</span> (entity != <span class="hljs-keyword">null</span>) {
                    InputStream instream = entity.getContent();
                    <span class="hljs-keyword">try</span> {
                        instream.read();
                        <span class="hljs-comment">// do something useful with the response</span>
                    } <span class="hljs-keyword">catch</span> (IOException ex) {
                        <span class="hljs-comment">// In case of an IOException the connection will be released</span>
                        <span class="hljs-comment">// back to the connection manager automatically</span>
                        <span class="hljs-keyword">throw</span> ex;
                    } <span class="hljs-keyword">finally</span> {
                        <span class="hljs-comment">// Closing the input stream will trigger connection release</span>
                        instream.close();
                    }
                }
            } <span class="hljs-keyword">finally</span> {
                response.close();
            }
        } <span class="hljs-keyword">finally</span> {
            httpclient.close();
        }
    }
}</pre> 
<p>在HttpClient Manual connection release的例子中可以看到，从内层依次调用的是instream.close()、response.close()、httpClient.close()，那么它们有什么区别呢？</p> 
<p>&nbsp;</p> 
<p><span style="color:#9b00d3"><strong>instream.close()</strong></span></p> 
<p>在主动操作输入流，或者调用EntityUtils.toString(httpResponse.getEntity())时会调用instream.read()、instream.close()等方法。instream的实现类为org.apache.http.conn.EofSensorInputStream。</p> 
<p>在每次通过<span style="color:#ff0000">instream.read()</span>读取数据流后，都会判断流是否读取结束</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-annotation">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">int</span> l = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (isReadAllowed()) {
        <span class="hljs-keyword">try</span> {
            l = wrappedStream.read(b,  off,  len);
            checkEOF(l);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ex) {
            checkAbort();
            <span class="hljs-keyword">throw</span> ex;
        }
    }
    <span class="hljs-keyword">return</span> l;
}</pre> 
<p>在EofSensorInputStream#checkEOF()方法中如果eof=-1，流已经读完，如果连接可重用，就会尝试释放连接，否则关闭连接。</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkEOF</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> eof)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">if</span> ((wrappedStream != <span class="hljs-keyword">null</span>) &amp;&amp; (eof &lt; <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">boolean</span> scws = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// should close wrapped stream?</span>
            <span class="hljs-keyword">if</span> (eofWatcher != <span class="hljs-keyword">null</span>) {
                scws = eofWatcher.eofDetected(wrappedStream);
            }
            <span class="hljs-keyword">if</span> (scws) {
                wrappedStream.close();
            }
        } <span class="hljs-keyword">finally</span> {
            wrappedStream = <span class="hljs-keyword">null</span>;
        }
    }
}</pre> 
<p>ResponseEntityWrapper#eofDetected</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">eofDetected</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream wrapped)</span> <span class="hljs-keyword">throws</span> IOException </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// there may be some cleanup required, such as</span>
        <span class="hljs-comment">// reading trailers after the response body:</span>
        wrapped.close();
        releaseConnection(); <span class="hljs-comment">//释放连接 或 关闭连接</span>
    } <span class="hljs-keyword">finally</span> {
        cleanup();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}</pre> 
<p>ConnectionHolder#releaseConnection</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.managedConn) {
    	<span class="hljs-comment">//如果连接已经释放，直接返回</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.released) {
            <span class="hljs-keyword">return</span>;
        }
        
        <span class="hljs-keyword">this</span>.released = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//连接可重用，释放回连接池</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reusable) {
            <span class="hljs-keyword">this</span>.manager.releaseConnection(<span class="hljs-keyword">this</span>.managedConn,
                    <span class="hljs-keyword">this</span>.state, <span class="hljs-keyword">this</span>.validDuration, <span class="hljs-keyword">this</span>.tunit);
        } 
        <span class="hljs-comment">//不可重用，关闭连接</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">this</span>.managedConn.close();
                log.debug(<span class="hljs-string">"Connection discarded"</span>);
            } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ex) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.log.isDebugEnabled()) {
                    <span class="hljs-keyword">this</span>.log.debug(ex.getMessage(), ex);
                }
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">this</span>.manager.releaseConnection(
                        <span class="hljs-keyword">this</span>.managedConn, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, TimeUnit.MILLISECONDS);
            }
        }
    }
}</pre> 
<p>&nbsp;</p> 
<p>如果没有instream.read()读取数据，在<span style="color:#ff0000">instream.close()</span>时会调用EofSensorInputStream#checkClose()，也会有类似上面的逻辑。</p> 
<p>所以就如官方例子注释的一样，在正常操作输入流后，会释放连接。</p> 
<p>&nbsp;</p> 
<p><span style="color:#9b00d3"><strong>response.close()</strong></span></p> 
<p>最终是调用ConnectionHolder#abortConnection()</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abortConnection</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.managedConn) {
    	<span class="hljs-comment">//如果连接已经释放，直接返回</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.released) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">this</span>.released = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
        	<span class="hljs-comment">//关闭连接</span>
            <span class="hljs-keyword">this</span>.managedConn.shutdown();
            log.debug(<span class="hljs-string">"Connection discarded"</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ex) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.log.isDebugEnabled()) {
                <span class="hljs-keyword">this</span>.log.debug(ex.getMessage(), ex);
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">this</span>.manager.releaseConnection(
                    <span class="hljs-keyword">this</span>.managedConn, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, TimeUnit.MILLISECONDS);
        }
    }
}</pre> 
<p>所以，如果在调用response.close()之前，没有读取过输入流，也没有关闭输入流，那么连接没有被释放，released=false，就会关闭连接。</p> 
<p>&nbsp;</p> 
<p><span style="color:#9b00d3"><strong>httpClient.close()</strong></span></p> 
<p>最终调用的是InternalHttpClient#close()，会关闭整个连接管理器，并关闭连接池中所有连接。</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.connManager.shutdown();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closeables != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Closeable closeable: <span class="hljs-keyword">this</span>.closeables) {
            <span class="hljs-keyword">try</span> {
                closeable.close();
            } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ex) {
                <span class="hljs-keyword">this</span>.log.error(ex.getMessage(), ex);
            }
        }
    }
}</pre> 
<p>&nbsp;</p> 
<p><strong>总结：</strong></p> 
<p>1、使用连接池时，要正确释放连接需要通过读取输入流 或者 instream.close()方式；</p> 
<p>2、如果已经释放连接，response.close()直接返回，否则会关闭连接；</p> 
<p>3、httpClient.close()会关闭连接管理器，并关闭其中所有连接，谨慎使用。</p> 
<p>&nbsp;</p> 
<p><strong>2.5、过期和空闲连接清理</strong></p> 
<p><strong><span style="color:#9b00d3">在连接池保持连接的这段时间，可能出现两种导致连接过期或失效的情况：</span></strong></p> 
<p><span style="color:#ff0000">1、连接保持时间到期</span></p> 
<p>每个连接对象PoolEntry都有expiry到期时间，在创建和释放归还连接是都会为expiry到期时间赋值，在连接池保持连接的这段时间，连接已经到了过期时间（注意，这个过期时间是为了管理连接所设定的，并不是指的TCP连接真的不能使用了）。</p> 
<p>对于这种情况，在每次从连接池获取连接时，都会从routeToPool的available队列获取Entry并检测此时Entry是否已关闭或者已过期，若是则关闭并分别从routeToPool、httpConnPool的available队列移除该Entry，之后再次尝试获取连接。代码如下</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cpp"><span class="hljs-comment">/**AbstractConnPool#getPoolEntryBlocking()*/</span>
<span class="hljs-keyword">for</span> (;;) {
	<span class="hljs-comment">//从availabe链表头迭代查找符合state的entry</span>
    entry = pool.getFree(state);
    <span class="hljs-comment">//找不到entry，跳出</span>
    <span class="hljs-keyword">if</span> (entry == null) {
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">//如果entry已关闭或已过期，关闭entry，并从routeToPool、httpConnPool的available队列移除</span>
    <span class="hljs-keyword">if</span> (entry.isClosed() || entry.isExpired(System.currentTimeMillis())) {
        entry.close();
        <span class="hljs-keyword">this</span>.available.remove(entry);
        pool.<span class="hljs-built_in">free</span>(entry, <span class="hljs-keyword">false</span>);
    } 
    <span class="hljs-keyword">else</span> {  <span class="hljs-comment">//找到可用连接</span>
        <span class="hljs-keyword">break</span>;
    }
}</pre> 
<p><span style="color:#ff0000">2、底层连接已被关闭</span></p> 
<p>在连接池保持连接的时候，可能会出现连接已经被服务端关闭的情况，而此时连接的客户端并没有阻塞着去接收服务端的数据，所以客户端不知道连接已关闭，无法关闭自身的socket。</p> 
<p>对于这种情况，在从连接池获取可用连接时无法知晓，在获取到可用连接后，如果连接是打开的，会有判断连接是否陈旧的逻辑，如下</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs cpp"><span class="hljs-comment">/**MainClientExec#execute()*/</span>
<span class="hljs-keyword">if</span> (config.isStaleConnectionCheckEnabled()) {
    <span class="hljs-comment">// validate connection</span>
    <span class="hljs-keyword">if</span> (managedConn.isOpen()) {
        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">log</span>.debug(<span class="hljs-string">"Stale connection check"</span>);
        <span class="hljs-keyword">if</span> (managedConn.isStale()) {
            <span class="hljs-keyword">this</span>.<span class="hljs-built_in">log</span>.debug(<span class="hljs-string">"Stale connection detected"</span>);
            managedConn.close();
        }
    }
}</pre> 
<p>isOpen()会通过连接的状态判断连接是否是open状态；</p> 
<p>isStale()会通过socket输入流尝试读取数据，在读取前暂时将soTimeout设置为1ms，如果读取到的字节数小于0，即已经读到了输入流的末尾，或者发生了IOException，可能连接已经关闭，那么isStale()返回true，需要关闭连接；如果读到的字节数大于0，或者发生了SocketTimeoutException，可能是读超时，isStale()返回false，连接还可用。</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-javadoc">/**BHttpConnectionBase#isStale()*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStale</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!isOpen()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bytesRead = fillInputBuffer(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> bytesRead &lt; <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> SocketTimeoutException ex) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ex) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}</pre> 
<p>如果在整个判断过程中发现连接是陈旧的，就会关闭连接，那么这个从连接池获取的连接就是不可用的，后面的代码逻辑里会重建当前PoolEntry的socket连接，继续后续请求逻辑。</p> 
<p><strong><span style="color:#9b00d3">后台监控线程检查连接</span></strong></p> 
<p>上述过程是在从连接池获取连接后，检查连接是否可用，如不可用需重新建立socket连接，建立连接的过程是比较耗时的，可能导致性能问题，也失去了连接池的意义，针对这种情况，HttpClient采取一个策略，通过一个后台的监控线程定时的去检查连接池中连接是否还“新鲜”，如果过期了，或者空闲了一定时间则就将其从连接池里删除掉。</p> 
<p>ClientConnectionManager提供了 closeExpiredConnections()和closeIdleConnections()两个方法，关闭过期或空闲了一段时间的连接，并从连接池删除。</p> 
<p>closeExpiredConnections()<br> 该方法关闭超过连接保持时间的连接，并从池中移除。</p> 
<p>closeIdleConnections(timeout,tunit)</p> 
<p>该方法关闭空闲时间超过timeout的连接，空闲时间从交还给连接池时开始，不管是否已过期，超过空闲时间则关闭。</p> 
<p>下面是httpClient官方给出的清理过期、空闲连接的例子</p> 
<pre class="brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: true; smart-tabs: true; tab-size: 4; toolbar: true; hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleConnectionMonitorThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClientConnectionManager connMgr;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> shutdown;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdleConnectionMonitorThread</span><span class="hljs-params">(ClientConnectionManager connMgr)</span> </span>{
        <span class="hljs-keyword">super</span>();
        <span class="hljs-keyword">this</span>.connMgr = connMgr;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (!shutdown) {
                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
                    wait(<span class="hljs-number">5000</span>);
                    <span class="hljs-comment">// Close expired connections</span>
                    connMgr.closeExpiredConnections();
                    <span class="hljs-comment">// Optionally, close connections</span>
                    <span class="hljs-comment">// that have been idle longer than 30 sec</span>
                    connMgr.closeIdleConnections(<span class="hljs-number">30</span>, TimeUnit.SECONDS);
                }
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException ex) {
            <span class="hljs-comment">// terminate</span>
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>{
        shutdown = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            notifyAll();
        }
    }
}</pre> 
<p>&nbsp;</p> 
<h1>三、如何设置合理的参数</h1> 
<p>关于设置合理的参数，这个说起来真的不是一个简单的话题，需要考虑的方面也听到，是需要一定经验的，这里先简单的说一下自己的理解，欢迎各位批评指教。</p> 
<p>这里主要涉及两部分参数：连接数相关参数、超时时间相关参数</p> 
<p><strong><span style="color:#9b00d3">1、连接数相关参数</span></strong></p> 
<p>根据“利尔特法则”可以得到简单的公式：</p> 
<p><img title="bb1dddfc6ee63" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/loading.png" alt="bb1dddfc6ee63" width="240" height="30" border="0" style="padding-top:0px; padding-left:0px; display:inline; padding-right:0px; border-width:0px" data-src="http://images2015.cnblogs.com/blog/677054/201701/677054-20170125150656816-173079484.png"></p> 
<p>简单地说，利特尔法则解释了这三种变量的关系：L—系统里的请求数量、λ—请求到达的速率、W—每个请求的处理时间。例如，如果每秒10个请求到达，处理一个请求需要1秒，那么系统在每个时刻都有10个请求在处理。如果处理每个请求的时间翻倍，那么系统每时刻需要处理的请求数也翻倍为20，因此需要20个线程。连接池的大小可以参考 L。</p> 
<p>qps指标可以作为“λ—请求到达的速率”，由于httpClient是作为http客户端，故需要通过一些监控手段得到服务端集群访问量较高时的qps，如客户端集群为4台，服务端集群为2台，监控到每台服务端机器的qps为100，如果每个请求处理时间为1秒，那么2台服务端每个时刻总共有 100 * 2 * 1s = 200 个请求访问，平均到4台客户端机器，每台要负责50，即每台客户端的连接池大小可以设置为50。</p> 
<p>当然实际的情况是更复杂的，上面的请求平均处理时间1秒只是一种业务的，实际情况的业务情况更多，评估请求平均处理时间更复杂。所以在设置连接数后，最好通过比较充分性能测试验证是否可以满足要求。</p> 
<p>还有一些Linux系统级的配置需要考虑，如单个进程能够打开的最大文件描述符数量open files默认为1024，每个与服务端建立的连接都需要占用一个文件描述符，如果open files值太小会影响建立连接。</p> 
<p>还要注意，连接数主要包含<span style="color:#ff0000">maxTotal-连接总数</span><span style="color:#000000">、</span><span style="color:#ff0000">maxPerRoute-路由最大连接数</span>，尤其是maxPerRoute默认值为2，很小，设置不好的话即使maxTotal再大也无法充分利用连接池。</p> 
<p><strong><span style="color:#9b00d3">2、超时时间相关参数</span></strong></p> 
<p><span style="color:#ff0000">connectTimeout&nbsp; --&nbsp; 连接超时时间</span></p> 
<p>根据网络情况，内网、外网等，可设置连接超时时间为2秒，具体根据业务调整</p> 
<p><span style="color:#ff0000">socketTimeout&nbsp; --&nbsp; 读超时时间（等待数据超时时间）</span></p> 
<p>需要根据具体请求的业务而定，如请求的API接口从接到请求到返回数据的平均处理时间为1秒，那么读超时时间可以设置为2秒，考虑并发量较大的情况，也可以通过性能测试得到一个相对靠谱的值。</p> 
<p>socketTimeout有默认值，也可以针对每个请求单独设置。</p> 
<p><span style="color:#ff0000">connectionRequestTimeout&nbsp; --&nbsp; 从池中获取连接超时时间</span></p> 
<p>建议设置500ms即可，不要设置太大，这样可以使连接池连接不够时不用等待太久去获取连接，不要让大量请求堆积在获取连接处，尽快抛出异常，发现问题。</p> 
<p>&nbsp;</p> 
<p><strong>参考资料：</strong></p> 
<p>httpClient 4.3.x configuration 官方样例</p> 
<p>使用httpclient必须知道的参数设置及代码写法、存在的风险</p> 
<p>HttpClient连接池的连接保持、超时和失效机制</p> 
<p>HttpClient连接池原理及一次连接时序图</p>
        </div>
            <div class="margin-top-20"></div>
        	<div><script async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/f.txt"></script>
<!-- 正文底部广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6208739752673518" data-ad-slot="9020893119" data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
    </div>
		<div>
	    	<div class="relative">相关文章</div>
	    	<ul class="relative_list">
		                <li>
		                    1. <a href="http://www.voidcn.com/article/p-stxwogrj-bdx.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读"> HttpClient 4.3连接池参数配置及源码解读 </a>
		                </li>
		                <li>
		                    2. <a href="http://www.voidcn.com/article/p-mofbtzib-vc.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读_0"> HttpClient 4.3连接池参数配置及源码解读_0 </a>
		                </li>
		                <li>
		                    3. <a href="http://www.voidcn.com/article/p-vxiawkma-xn.html" target="_blank" title="配置使用连接池的httpClient"> 配置使用连接池的httpClient </a>
		                </li>
		                <li>
		                    4. <a href="http://www.voidcn.com/article/p-ubwhrhks-m.html" target="_blank" title="DBCP连接池配置参数说明"> DBCP连接池配置参数说明 </a>
		                </li>
		                <li>
		                    5. <a href="http://www.voidcn.com/article/p-zawkbirr-zw.html" target="_blank" title="DBCP连接池配置参数说明 ."> DBCP连接池配置参数说明 . </a>
		                </li>
		                <li>
		                    6. <a href="http://www.voidcn.com/article/p-hjdicvjq-bkg.html" target="_blank" title="Tomcat7.0中配置DBCP连接池以及连接池参数介绍"> Tomcat7.0中配置DBCP连接池以及连接池参数介绍 </a>
		                </li>
		                <li>
		                    7. <a href="http://www.voidcn.com/article/p-rhgenkwc-wz.html" target="_blank" title="连接池参数解析"> 连接池参数解析 </a>
		                </li>
		                <li>
		                    8. <a href="http://www.voidcn.com/article/p-arscizyi-ho.html" target="_blank" title="Tomcat配置DataSource,连接池数据源"> Tomcat配置DataSource,连接池数据源 </a>
		                </li>
		                <li>
		                    9. <a href="http://www.voidcn.com/article/p-drldjxvx-ow.html" target="_blank" title="spring配置数据源连接池"> spring配置数据源连接池 </a>
		                </li>
		                <li>
		                    10. <a href="http://www.voidcn.com/article/p-vynoxyjc-zd.html" target="_blank" title="Tomcat配置数据源连接池"> Tomcat配置数据源连接池 </a>
		                </li>
	            <li><a href="http://www.voidcn.com/relative/p-wohpkcfq-gt.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读 的相关文章"> 更多相关文章...</a></li>
	        </ul>

                <div class="margin-top-20"></div>
                <div>
                    <div><script async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/f.txt"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6208739752673518" data-ad-slot="3534271784"></ins>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
                </div>
            <div class="margin-top-20"></div>

	        <div class="relative">相关标签/搜索</div>
	        <ul>
	        			<a target="_blank" href="http://www.voidcn.com/tag/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8F%82%E6%95%B0" title="连接池参数"> <span class="new-label">连接池参数</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE+%E8%AF%A6%E8%A7%A3" title="连接池配置 详解"> <span class="new-label">连接池配置 详解</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE" title="连接池配置"> <span class="new-label">连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/httpclient+4.3" title="httpclient 4.3"> <span class="new-label">httpclient 4.3</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE" title="数据源连接配置"> <span class="new-label">数据源连接配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/spring%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE" title="spring连接池配置"> <span class="new-label">spring连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/BoneCP%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE" title="BoneCP连接池配置"> <span class="new-label">BoneCP连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/c3p0%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0" title="c3p0配置连接池"> <span class="new-label">c3p0配置连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/Tomcat6.0+%E8%BF%9E%E6%8E%A5%E6%B1%A0+oracle+%E9%85%8D%E7%BD%AE" title="Tomcat6.0 连接池 oracle 配置"> <span class="new-label">Tomcat6.0 连接池 oracle 配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/tag/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE" title="C3P0连接池配置"> <span class="new-label">C3P0连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/3116831" title="连接池配置"> <span class="new-label">连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/462658" title="源码连接"> <span class="new-label">源码连接</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/2914913" title="数据源连接池配置"> <span class="new-label">数据源连接池配置</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/336016" title="1.连接池"> <span class="new-label">1.连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/3198141" title="连接池"> <span class="new-label">连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/1304638" title="连接池"> <span class="new-label">连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/936662" title="连接池"> <span class="new-label">连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/1211632" title="连接池"> <span class="new-label">连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/1225988" title="Proxool连接池"> <span class="new-label">Proxool连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/cata/2264795" title="dbcp 连接池"> <span class="new-label">dbcp 连接池</span></a>
	        			<a target="_blank" href="http://www.voidcn.com/column/network" title="系统网络"> <span class="new-label">系统网络</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/pygaic"><span class="new-label">storm-jdbc连接池配置</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/zhgnps"><span class="new-label">springboot配置hikari连接池</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/apkhta"><span class="new-label">hikari 连接池配置 maximumPoolSize</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/szctwu"><span class="new-label">jms配置,连接池</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/pimtrq"><span class="new-label">yml配置mysql连接池</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/cbxcnx"><span class="new-label">spring配置hikari 连接池详解</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/cvhpve"><span class="new-label">BlueDroid设置连接参数</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/xfcrfv"><span class="new-label">springboot的redis连接池配置</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/rplszs"><span class="new-label">spring boot设置连接池</span></a>
		        		<a target="_blank" href="http://www.voidcn.com/search/panuvx"><span class="new-label">hikari 连接池 重置</span></a>
	        </ul>
	    </div>
    
    <div class="article_social">
        <div class="article_like">
            <div class="circle circle-like" id="my_zan" data_id="eEvIVb6"></div>
        </div>
        <div class="clear"></div>
        <div class="share">
			<span class="share-left bdsharebuttonbox bdshare-button-style0-24" data-tag="share_1" data-bd-bind="1565603617738">
				<a href="http://www.voidcn.com/article/p-wohpkcfq-gt.html#" class="bds_more icon-share" data-cmd="more">
					<span class="bds_count" data-cmd="count" title="累计分享0次">0</span>
				</a>
			</span>
			<div class="share-right action action-share bdsharebuttonbox bdshare-button-style0-24" data-tag="share_1" data-bd-bind="1565603617738">
				<span class="bdshare">
					<a href="http://www.voidcn.com/article/p-wohpkcfq-gt.html#" class="bds_sinaweibo icon-weibo" data-cmd="tsina" title="分享到新浪微博">分享到微博</a>
					<a href="http://www.voidcn.com/article/p-wohpkcfq-gt.html#" class="bds_weixin icon-wechat" data-cmd="weixin" title="分享到微信">分享到微信</a>
					<a href="http://www.voidcn.com/article/p-wohpkcfq-gt.html#" class="bds_qq icon-qq" data-cmd="sqq" title="分享到QQ好友">分享到QQ</a>
				</span>
			</div>
		</div>
		<div class="clear"></div>
    <div class="bottom_plink huodong-detail-plink-banner clearfix">
        </div>
    </div>



	<script>
		$(function () {
		    $("#originfo").text("http://blog.csdn.net/umke888/article/details/54881946");
		    $("#originfo").hover(function(){
		        $("#originfo").attr("href" , "/link?url=http://blog.csdn.net/umke888/article/details/54881946");
			},function(){
		        $("#originfo").attr("href" , "javascript:void()");
			});
		});
	</script>
	
    <script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/article.js.下载" type="text/javascript"></script>

</div>
<div class="span3 article_right_side">
    <div class="right_top">
    	<div id="right_site_articles" class="article_detail_bg">
    <div class="article-part-title">
        <span>每日一句</span>
    </div>
    <ul class="side_article_list">
    	每一个你不满意的现在，都有一个你没有努力的曾经。
    </ul>
</div><script async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/f.txt"></script>
<!-- 侧边栏 自适应 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6208739752673518" data-ad-slot="8798382113" data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

    <div id="right_site_articles">
        <div class="article-part-title">
            <span>最新文章</span>
        </div>
        <ul class="side_article_list">
	                <li class="side_article_list_item">1.
	                    <a href="http://www.voidcn.com/article/p-enhcxqwk-byq.html" target="_blank" title="ruby-on-rails – Rails 3按字母顺序列出ActiveRecord对象"> ruby-on-rails – Rails 3按字母顺序列出ActiveRecord对象 </a>
	                </li>
	                <li class="side_article_list_item">2.
	                    <a href="http://www.voidcn.com/article/p-poabwsnm-byq.html" target="_blank" title="php – 存储国家/地区代码而不仅仅是国家/地区名称本身有哪些实际优势？"> php – 存储国家/地区代码而不仅仅是国家/地区名称本身有哪些实际优势？ </a>
	                </li>
	                <li class="side_article_list_item">3.
	                    <a href="http://www.voidcn.com/article/p-sccgiuzg-byq.html" target="_blank" title="使用c#开发的所有应用程序都不是面向对象的？"> 使用c#开发的所有应用程序都不是面向对象的？ </a>
	                </li>
	                <li class="side_article_list_item">4.
	                    <a href="http://www.voidcn.com/article/p-tbqnjefa-byq.html" target="_blank" title="perl – 删除包含特定字符的文件中的所有行"> perl – 删除包含特定字符的文件中的所有行 </a>
	                </li>
	                <li class="side_article_list_item">5.
	                    <a href="http://www.voidcn.com/article/p-xgddnqbf-byq.html" target="_blank" title="javascript – href总是“未定义”"> javascript – href总是“未定义” </a>
	                </li>
	                <li class="side_article_list_item">6.
	                    <a href="http://www.voidcn.com/article/p-qdcoguao-byq.html" target="_blank" title="Scala int String字符的值"> Scala int String字符的值 </a>
	                </li>
	                <li class="side_article_list_item">7.
	                    <a href="http://www.voidcn.com/article/p-oshwidho-byq.html" target="_blank" title="JAVA链接列表如何使用for循环进行循环？"> JAVA链接列表如何使用for循环进行循环？ </a>
	                </li>
	                <li class="side_article_list_item">8.
	                    <a href="http://www.voidcn.com/article/p-ppssfryq-byq.html" target="_blank" title="c – 如何在另一个struct中使用struct？"> c – 如何在另一个struct中使用struct？ </a>
	                </li>
	                <li class="side_article_list_item">9.
	                    <a href="http://www.voidcn.com/article/p-wmsjyzji-byq.html" target="_blank" title="关于C#中Math.Round的简单问题"> 关于C#中Math.Round的简单问题 </a>
	                </li>
	                <li class="side_article_list_item">10.
	                    <a href="http://www.voidcn.com/article/p-bajpnwjr-byq.html" target="_blank" title="PHP数字格式"> PHP数字格式 </a>
	                </li>
        </ul>
        
        
    </div>

    </div>

    <div class="operate_zone" style="position: fixed; top: 60px; width: 277px;">
<div id="right_site_articles" class="article_detail_bg margin-top10">
    <div class="article-part-title">
        <span><a href="http://www.voidcn.com/contact" target="_blank">本站公众号</a></span>
    </div>
    <div class="side_article_list user-head">
    	<span style="color: #5ba607;font-size:14px;">&nbsp;&nbsp;&nbsp;欢迎关注本站公众号,获取更多程序园信息</span><br>
    	<img src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/qrcode_develong_1.jpg" alt="开发小院">
    </div>
</div>

    <div id="right_site_articles">
        <div class="article-part-title">
            <span>相关文章</span>
        </div>
        <ul class="side_article_list">
	                <li class="side_article_list_item">1.
	                    <a href="http://www.voidcn.com/article/p-stxwogrj-bdx.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读"> HttpClient 4.3连接池参数配置及源码解读 </a>
	                </li>
	                <li class="side_article_list_item">2.
	                    <a href="http://www.voidcn.com/article/p-mofbtzib-vc.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读_0"> HttpClient 4.3连接池参数配置及源码解读_0 </a>
	                </li>
	                <li class="side_article_list_item">3.
	                    <a href="http://www.voidcn.com/article/p-vxiawkma-xn.html" target="_blank" title="配置使用连接池的httpClient"> 配置使用连接池的httpClient </a>
	                </li>
	                <li class="side_article_list_item">4.
	                    <a href="http://www.voidcn.com/article/p-ubwhrhks-m.html" target="_blank" title="DBCP连接池配置参数说明"> DBCP连接池配置参数说明 </a>
	                </li>
	                <li class="side_article_list_item">5.
	                    <a href="http://www.voidcn.com/article/p-zawkbirr-zw.html" target="_blank" title="DBCP连接池配置参数说明 ."> DBCP连接池配置参数说明 . </a>
	                </li>
	                <li class="side_article_list_item">6.
	                    <a href="http://www.voidcn.com/article/p-hjdicvjq-bkg.html" target="_blank" title="Tomcat7.0中配置DBCP连接池以及连接池参数介绍"> Tomcat7.0中配置DBCP连接池以及连接池参数介绍 </a>
	                </li>
	                <li class="side_article_list_item">7.
	                    <a href="http://www.voidcn.com/article/p-rhgenkwc-wz.html" target="_blank" title="连接池参数解析"> 连接池参数解析 </a>
	                </li>
	                <li class="side_article_list_item">8.
	                    <a href="http://www.voidcn.com/article/p-arscizyi-ho.html" target="_blank" title="Tomcat配置DataSource,连接池数据源"> Tomcat配置DataSource,连接池数据源 </a>
	                </li>
	                <li class="side_article_list_item">9.
	                    <a href="http://www.voidcn.com/article/p-drldjxvx-ow.html" target="_blank" title="spring配置数据源连接池"> spring配置数据源连接池 </a>
	                </li>
	                <li class="side_article_list_item">10.
	                    <a href="http://www.voidcn.com/article/p-vynoxyjc-zd.html" target="_blank" title="Tomcat配置数据源连接池"> Tomcat配置数据源连接池 </a>
	                </li>
        </ul>
        
        	<div style="padding-left:10px;font-size:14px;padding-bottom:10px;">
        		<a href="http://www.voidcn.com/relative/p-wohpkcfq-gt.html" target="_blank" title="HttpClient 4.3连接池参数配置及源码解读 的相关文章"> &gt;&gt;更多相关文章&lt;&lt; </a>
    		</div>
        
    </div>

    </div>
</div>

	</div>

	<script type="text/javascript">
        $('table').each(function (i) {
            var size = $(this).children().size();
            if (size > 1) {
                $(this).attr('class', "table table-bordered");
            } else if (size == 1) {
                var e11 = $(this).children(":first");
                var e1 = e11[0];
                var name = e1.nodeName.toLowerCase();
                if ("tbody" == name) {
                    if (e1.children.length > 1) {
                        $(this).attr('class', "table table-bordered");
                    } else if (e1.children.length == 1) {
                        var e12 = e1.children[0];
                        var name2 = e12.nodeName.toLowerCase();
                        if ("tr" == name2) {
                            if (e12.children.length > 1) {
                                $(this).attr('class', "table table-bordered");
                            }
                        }
                    }
                }
            }
        });
        window.page = 0;
        window.last = 0;
        window.first = true;
        resize_article_image('#nei', 550);
        
        
        
		+ (function($){
			window._bd_share_config = {
				common: {
					"bdText": "【" + $("title").text() + "】" + $(".post-content p:lt(2)").text(),
					"bdMini": "2",
					"bdMiniList": false,
					"bdPic": $(".post-content img:first") ? $(".post-content img:first").attr("src") : "",
					"bdStyle": "0",
					"bdSize": "24"
				},
				share: [{
					bdCustomStyle: 'http://static02.voidcn.com/voidcn/css/share.css'
				}],
			};
			with(document) 0[(getElementsByTagName("head")[0] || body).appendChild(createElement("script")).src = "http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion=" + ~ ( - new Date() / 36e5)];
		})(window.jQuery);
    </script>
</div>
<script type="text/javascript" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/highlight.pack.js.下载"></script>
<link href="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/docco.css" media="screen" rel="stylesheet" type="text/css">
<script type="text/javascript">
$('pre').each(function(i, e) {
    hljs.highlightBlock(e, "<span class='indent'>  </span>", false)
});
</script>
<div class="footer">
    <div class="footer-inner" style="padding-top: 50px;padding-bottom: 50px">
        <a href="http://www.voidcn.com/contact" target="_blank">意见反馈</a>
        <a href="http://www.voidcn.com/search">最近搜索</a>
        <a href="http://www.voidcn.com/recent">最新文章</a>
       	<script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/z_stat.php" language="JavaScript"></script><script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/core.php" charset="utf-8" type="text/javascript"></script><a href="https://www.cnzz.com/stat/website.php?web_id=1258680759" target="_blank" title="站长统计">站长统计</a>
        <a href="http://cn.voidcc.com/" target="_blank">程序问答</a>
        <a href="http://hk.voidcc.com/" target="_blank">程序問答</a>

       		<div style="display:none;"><script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/z_stat(1).php" language="JavaScript"></script><script src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/core(1).php" charset="utf-8" type="text/javascript"></script><a href="https://www.cnzz.com/stat/website.php?web_id=1261868352" target="_blank" title="站长统计">站长统计</a></div>
    </div>
    <div style="display:none;">
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "https://hm.baidu.com/hm.js?05fb07b91f60527211b85c9c9b431b73";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>
	</div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/js"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-77509369-1');
    </script>
</div>

<script type="text/javascript" src="./HttpClient 4.3连接池参数配置及源码解读 - 程序园_files/tip.js.下载" async=""></script>


<div class="return" title="返回顶部" style="display: block;"></div></body></html>